---
output: github_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%"
)
```

# goServeR

[![goserveR status badge](https://sounkou-bioinfo.r-universe.dev/goserveR/badges/version)](https://sounkou-bioinfo.r-universe.dev/goserveR)

This package provides an interface to a simple HTTP file server written in go (go part mostly written in the begining with a fair amount of hallucination by a LLM).

The server supports range requests and unbounded CORS. It uses the cgo package to call Go functions from R using the R C extension mechanisms. This is an experimentation with the R C extension mechanism without the very convenient Rcpp.

The server was very insecure but useful for my use case of serving local BCF/BAM files to an [ambiorix](https://ambiorix.dev/) app using [igv.js](https://github.com/igvteam/igv.js) (because {httpuv} does not support range requests [as of now](https://github.com/rstudio/httpuv/issues/259)). This can be installed from [r-universe](https://sounkou-bioinfo.r-universe.dev/goserveR) and requires a go installation. We've added TLS support, basic authentication layer and other improvements since the initial version and we will add allowlisting and other security features in the future.

## INSTALL

```bash

## install golang via apt/yum/brew or binary and put it in the path
## to build from source

go || sudo apt-get install --yes golang
## clone the repo and install
git clone https://github.com/sounkou-bioinfo/goServeR.git
cd goServeR/
R CMD INSTALL  .
# or github via remotes
Rscript -e 'remotes::install_github("sounkou-bioinfo/goServeR")'
# or via r-universe 
Rscript -e "install.packages('goserveR', repos = c('https://sounkou-bioinfo.r-universe.dev'))"

```

## Usage Example

From the command line, you can start a server in the background and test it with curl
```bash
# Start the server in the background
Rscript -e "goserveR::runServer(addr = '0.0.0.0:8080')" &
pid=$!
curl -L http://0.0.0.0:8080/${PWD}
kill -9 $pid

# Or run it interactively and use Ctrl+C to stop
Rscript -e "goserveR::runServer(addr = '0.0.0.0:8080', blocking = TRUE)"
```


R starts a blocking server (blocks R session) with

```{r blocking}
library(goserveR)
# set timeout to 5 seconds for demo purpose
# this will stop the server after 5 seconds
setTimeLimit(elapsed = 5, transient = TRUE)
runServer(dir = ".", addr = "0.0.0.0:8080", silent = TRUE)
setTimeLimit()
```

To start a background server and get a handle

```{r background}
h <- runServer(dir = ".", addr = "0.0.0.0:8080", blocking = FALSE, silent = TRUE)
listServers() |> str()
currentDir <- normalizePath(".")
readLines(paste0("http://0.0.0.0:8080/", currentDir)) |>
  head(10)
shutdownServer(h)
```

### Authentication and TLS/HTTPS Support

The package supports both API key authentication and TLS/HTTPS connections. You can use them separately or together for secure authenticated file serving:

```{r auth_tls}

# Get paths to example certificate and key files
certfile <- system.file("extdata", "cert.pem", package = "goserveR")
keyfile <- system.file("extdata", "key.pem", package = "goserveR")
# write test file
writeLines("Hello from goServeR!", "test.txt")

# HTTP server with authentication
h_http_auth <- runServer(dir = ".", addr = "127.0.0.1:8080", prefix = "/", blocking = FALSE, 
                         auth_keys = c("secret123", "token456"), silent = TRUE)

# Test authentication - wrong key should fail
tryCatch({
  download.file("http://127.0.0.1:8080/test.txt", 
                destfile = tempfile(),
                headers = c("X-API-Key" = "wrongkey"),
                quiet = TRUE)
}, error = function(e) {
  cat("Authentication failed as expected\n")
})

# Test authentication - correct key should succeed
temp_file <- tempfile()
download.file("http://127.0.0.1:8080/test.txt", 
              destfile = temp_file,
              headers = c("X-API-Key" = "secret123"),
              quiet = TRUE)

readLines(temp_file)

unlink(temp_file)

# HTTPS server with authentication
h_https_auth <- runServer(
  dir = ".", 
  addr = "127.0.0.1:8443", 
  tls = TRUE,
  prefix = "/",
  certfile = certfile,
  keyfile = keyfile,
  auth_keys = c("secure_key_123"),
  blocking = FALSE,
  silent = TRUE
)

# Test HTTPS with authentication using download.file
temp_file_https <- tempfile()
download.file("https://127.0.0.1:8443/test.txt", 
                destfile = temp_file_https,
                headers = c("X-API-Key" = "secure_key_123"),
                quiet = TRUE)

readLines(temp_file_https)  

listServers() |> str()

# Cleanup
shutdownServer(h_http_auth)
shutdownServer(h_https_auth)
unlink("test.txt")
```

### Multiple Servers

You can run multiple servers simultaneously on different ports:

```{r multiple}
# Start multiple servers
h1 <- runServer(dir = ".", addr = "127.0.0.1:8081", blocking = FALSE, silent = TRUE)
h2 <- runServer(dir = ".", addr = "127.0.0.1:8082", blocking = FALSE, silent = TRUE)
h3 <- runServer(dir = ".", addr = "127.0.0.1:8083", blocking = FALSE, silent = TRUE)

# List all running servers
listServers() |> str()

# Access different servers

#Server 1 (port 8081) 
length(readLines(paste0("http://127.0.0.1:8081/", normalizePath("."))))
#Server 2 (port 8082)
length(readLines(paste0("http://127.0.0.1:8082/", normalizePath("."))))
#Server 3 (port 8083)
length(readLines(paste0("http://127.0.0.1:8083/", normalizePath("."))))

# Shutdown all servers
shutdownServer(h1)
shutdownServer(h2)
shutdownServer(h3)

# Verify cleanup
length(listServers())
```

### Multiple Directories from Single Server

You can serve multiple directories from the same server instance by providing vectors of directories and prefixes:

```{r multiple_dirs}
# Create test directories
dir.create("test_data", showWarnings = FALSE)
dir.create("test_docs", showWarnings = FALSE)
writeLines("Sample data content", "test_data/sample.txt")
writeLines("Documentation content", "test_docs/doc.txt")

# Start server with multiple directories
h_multi <- runServer(
    dir = c("test_data", "test_docs", "."),
    prefix = c("/api/data", "/docs", "/files"),
    addr = "127.0.0.1:8090",
    blocking = FALSE,
    silent = TRUE
)

# List server to see multiple directories
listServers() |> str()

# Access different endpoints
# Data endpoint
tryCatch({
    data_content <- readLines("http://127.0.0.1:8090/api/data/sample.txt")
    cat("Data content:", data_content, "\n")
}, error = function(e) cat("Error:", e$message, "\n"))

# Docs endpoint  
tryCatch({
    docs_content <- readLines("http://127.0.0.1:8090/docs/doc.txt")
    cat("Docs content:", docs_content, "\n")
}, error = function(e) cat("Error:", e$message, "\n"))

# Files endpoint (current directory)
tryCatch({
    files_count <- length(readLines(paste0("http://127.0.0.1:8090/files/", normalizePath("."))))
    cat("Files endpoint shows", files_count, "items\n")
}, error = function(e) cat("Error:", e$message, "\n"))

# Cleanup
shutdownServer(h_multi)
unlink(c("test_data", "test_docs"), recursive = TRUE)
```

### Background Log Handling

The package implements asynchronous log handling using R's async handling capabilities that was adapted from Simon Urbanek's [async callback pattern](https://github.com/s-u/background). Each server can have a custom log handler:

```{r log_handlers}
# Default console logging
h1 <- runServer(dir = ".", addr = "127.0.0.1:8350", blocking = FALSE, silent = FALSE)

# Custom file logger
logfile <- tempfile("custom_", fileext = ".log")
file_logger <- function(handler, message, user) {
  cat(format(Sys.time(), "[%Y-%m-%d %H:%M:%S]"), message, "\n", file = logfile, append = TRUE)
}
h2 <- runServer(dir = ".", addr = "127.0.0.1:8351", blocking = FALSE, 
                silent = FALSE, log_handler = file_logger)
# read some lines to generate logs
bunk <- readLines(paste0("http://127.0.0.1:8351/", normalizePath(".")))
# Custom console logger with prefix
console_logger <- function(handler, message, user) {
  cat("\n*** [CUSTOM-SERVER] ***", message, "*** END ***\n")
  flush.console()
}
h3 <- runServer(dir = ".", addr = "127.0.0.1:8352", blocking = FALSE, 
                silent = FALSE, log_handler = console_logger)
bunk <- readLines(paste0("http://127.0.0.1:8352/", normalizePath(".")))
# Silent mode (no logs)
h4 <- runServer(dir = ".", addr = "127.0.0.1:8353", blocking = FALSE, silent = TRUE)

listServers() |> str()

# let's get the log by making R idle !
Sys.sleep(5)
shutdownServer(h1)
shutdownServer(h2)
shutdownServer(h3)
shutdownServer(h4)


# Check custom log file
if (file.exists(logfile)) {
  cat(readLines(logfile, n = 3), sep = "\n")
}
```

## On background log handlers

An important note is that the handler may run at unpredictable times, and are removed when the server is shutdown, so there is no guarantee that they may run when go write to the log pipe.


## How it works ?

We wrote a standard Go HTTP file server, created a static library from it, and then wrote the usual R C API wrappers for the cgo (static) library. Interrupts are now handled entirely at the C level: the Go server runs in a background thread, and the main C thread periodically checks for user interrupts using the R API. If an interrupt is detected, the C code signals the Go server to shut down. This approach is robust, portable, and keeps all R session control in C, not Go. Morover logging is now handled asynchronously using asynchronous input handlers as adapted from Simon Urbanek's [async callback pattern](https://github.com/s-u/background).

## On TLS Certificates
**Note**: The included certificate files are for testing purposes only and should not be used in production. For development with browser-trusted certificates, use `mkcert` to generate locally-trusted certificates:

```bash
# Install mkcert (creates locally-trusted development certificates)
# On macOS: brew install mkcert
# On Linux: see https://github.com/FiloSottile/mkcert#installation

# Install the local CA in the system trust store
mkcert -install

# Generate certificate for localhost and local IP
mkcert localhost 127.0.0.1 ::1

# This creates localhost+2.pem (certificate) and localhost+2-key.pem (private key)
# Use these files with the certfile and keyfile parameters
```

For production use, get proper certificates from a Certificate Authority like Let's Encrypt:

```bash
# Using certbot for Let's Encrypt (example for Apache/nginx)
sudo certbot --nginx -d yourdomain.com

# Or generate self-signed certificates (browsers will show warnings)
openssl genpkey -algorithm RSA -out server.key -pkcs8
openssl req -new -x509 -key server.key -out server.crt -days 365
```

## TODO

- [ ] Try to implement a basic [Rook](https://github.com/jeffreyhorner/Rook) Rook specs interface using ?
  - [ ] issue here is since we elect to not call R from  go routines, we have to go through pipes or similar to get the request to the main R thread. we may use ideas from [background](https://github.com/s-u/background)


## REFERENCES

- <https://purrple.cat/blog/2017/05/14/calling-go-from-r/>
- <https://mahowald.github.io/go-ffi/>
- <https://cran.r-project.org/doc/manuals/r-devel/R-exts.pdf>
- <https://github.com/eliben/static-server>
